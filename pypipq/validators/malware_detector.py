"""Detects suspicious patterns in package files that may indicate malware.

This validator performs a static analysis of the package's source files,
searching for common indicators of malicious code, such as:
-   Long, potentially obfuscated strings (Base64 or hex-encoded).
-   Hardcoded public IP addresses, which might be used for C2 communication.
-   Keywords related to cryptocurrency mining.
"""
import os
import re
from typing import Dict, Any, Optional

from ..core.base_validator import BaseValidator
from ..core.config import Config


class MalwareDetector(BaseValidator):
    """Scans package files for suspicious string patterns.

    This validator walks through the extracted package directory and reads
    the content of each file to check for patterns commonly associated with
    malware.
    """
    name = "MalwareDetector"
    category = "Security"
    description = "Scans package files for suspicious patterns indicative of malware."

    def __init__(self, pkg_name: str, metadata: Dict[str, Any], config: Config, **kwargs) -> None:
        """Initializes the MalwareDetector."""
        super().__init__(pkg_name, metadata, config, **kwargs)
        self.crypto_keywords = self.config.get("validators.MalwareDetector.crypto_keywords", [
            "cryptonight", "monero", "stratum", "xmr-stak"
        ])

    def _validate(self) -> None:
        """Performs the malware pattern scan."""
        if not self.extracted_path:
            self.add_info("Malware Scan", "Skipped because the package was not extracted.")
            return

        for root, _, files in os.walk(self.extracted_path):
            for file in files:
                file_path = os.path.join(root, file)
                try:
                    # Limit read size to avoid excessive memory usage on large files.
                    with open(file_path, "r", encoding="utf-8", errors="ignore") as f:
                        content = f.read(1024 * 1024)  # Read up to 1MB
                    self._find_suspicious_patterns(content, file_path)
                except (IOError, OSError):
                    # Ignore binary files or files we can't read.
                    continue

    def _find_suspicious_patterns(self, content: str, file_path: str) -> None:
        """Applies a set of regexes and keyword searches to the file content.

        Args:
            content (str): The content of the file to scan.
            file_path (str): The path to the file, for reporting purposes.
        """
        # Pattern for long Base64-like strings, which can hide malicious payloads.
        for match in re.finditer(r'[A-Za-z0-9+/=]{50,}', content):
            self.add_warning(
                f"Found a long, potentially Base64-encoded string in '{file_path}' "
                f"at position {match.start()}. This could be obfuscated code."
            )

        # Pattern for long hex-encoded strings.
        for match in re.finditer(r'(?:[0-9a-fA-F]{2}){20,}', content):
            self.add_warning(
                f"Found a long, potentially hex-encoded string in '{file_path}' "
                f"at position {match.start()}. This could be obfuscated code."
            )

        # Pattern for IP addresses, excluding common private ranges.
        for match in re.finditer(r'\b\d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3}\b', content):
            ip = match.group(0)
            if not (ip.startswith("192.168.") or ip.startswith("10.") or ip.startswith("172.16.") or ip == "127.0.0.1"):
                self.add_warning(f"Found a hardcoded public IP address ({ip}) in '{file_path}'.")

        # Keywords related to cryptocurrency mining.
        content_lower = content.lower()
        for keyword in self.crypto_keywords:
            if keyword in content_lower:
                self.add_warning(f"Found cryptocurrency-related keyword '{keyword}' in '{file_path}'.")

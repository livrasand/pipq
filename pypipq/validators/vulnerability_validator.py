"""Checks for known security vulnerabilities in a package.

This validator queries multiple advisory databases to determine if a specific
package version is affected by any known security vulnerabilities. It currently
integrates with:
-   OSV (Open Source Vulnerability format)
-   Safety DB (from pyup.io)
-   Snyk Vulnerability DB

It uses a local DBM cache to store OSV results to reduce redundant API calls.
"""
import json
import os
import time
from pathlib import Path
from typing import Dict, Any, List

import requests
from packaging.specifiers import SpecifierSet
from packaging.version import parse as parse_version

from ..core.base_validator import BaseValidator
from ..core.config import Config
from ..utils.vulnerability_db import VulnerabilityDB


class VulnerabilityValidator(BaseValidator):
    """Checks for known vulnerabilities using OSV, Safety DB, Snyk, and others."""

    name = "Vulnerabilities"
    category = "Security"
    description = "Checks for known vulnerabilities using multiple advisory databases."

    OSV_API_URL = "https://api.osv.dev/v1/query"
    SNYK_API_URL = "https://snyk.io/api/v1/vuln/pypi/"

    def __init__(self, pkg_name: str, metadata: Dict[str, Any], config: Config, **kwargs):
        """Initializes the VulnerabilityValidator."""
        super().__init__(pkg_name, metadata, config, **kwargs)
        self.timeout = self.config.get("validators.Vulnerabilities.timeout", 30)
        self.snyk_api_key = os.getenv("SNYK_API_KEY") or self.config.get("api_keys.snyk")

    def _validate(self) -> None:
        """Runs the vulnerability checks against all configured sources."""
        version = self.get_metadata_field("version")

        if not version or version == 'latest':
            self.add_warning("Could not determine a specific version; skipping vulnerability check.")
            return

        self._check_osv(self.pkg_name, version)
        self._check_safety_db(self.pkg_name, version)
        self._check_snyk(self.pkg_name, version)
        self._check_semgrep_rules(self.pkg_name, version)

    def _check_osv(self, pkg_name: str, version: str) -> None:
        """Checks for vulnerabilities using the OSV database, with local caching.

        Args:
            pkg_name (str): The name of the package.
            version (str): The version of the package.
        """
        try:
            # Use a context manager for safe DBM access.
            with VulnerabilityDB() as db:
                vulnerabilities = db.get_vulnerability(pkg_name)
                if vulnerabilities is None:
                    vulnerabilities = self._fetch_osv_vulnerabilities(pkg_name)
                    db.update_vulnerability(pkg_name, vulnerabilities)
            self._process_osv_results(vulnerabilities, version)
        except Exception as e:
            # If the local DB fails, fall back to a direct API query.
            self.add_warning(f"Could not access the local vulnerability database: {e}. Checking OSV directly.")
            self._check_osv_direct(pkg_name, version)

    def _check_osv_direct(self, pkg_name: str, version: str) -> None:
        """Performs a direct, non-cached check against the OSV API.

        Args:
            pkg_name (str): The name of the package.
            version (str): The version of the package.
        """
        try:
            vulnerabilities = self._fetch_osv_vulnerabilities(pkg_name)
            self._process_osv_results(vulnerabilities, version)
        except Exception as e:
            self.add_warning(f"Could not query the OSV API: {e}")

    def _process_osv_results(self, vulnerabilities: Dict[str, Any], version: str) -> None:
        """Processes the vulnerability data returned from OSV.

        Args:
            vulnerabilities (Dict[str, Any]): The OSV API response.
            version (str): The package version to check.
        """
        if not vulnerabilities or not vulnerabilities.get("vulns"):
            self.add_info("Vulnerability Scan (OSV)", "No known vulnerabilities found.")
            return

        for vuln in vulnerabilities["vulns"]:
            if self._is_version_affected(version, vuln.get("affected", [])):
                summary = vuln.get('summary', 'No summary available.')
                osv_id = vuln.get('id', 'N/A')
                self.add_error(f"Vulnerability Found (OSV): {osv_id} - {summary}")

    def _check_safety_db(self, pkg_name: str, version: str) -> None:
        """Checks for vulnerabilities using a local cache of the Safety DB.

        Args:
            pkg_name (str): The name of the package.
            version (str): The version of the package.
        """
        try:
            safety_db = self._get_safety_db()
            if pkg_name in safety_db:
                for spec, cve, description in safety_db[pkg_name]:
                    if parse_version(version) in SpecifierSet(spec):
                        self.add_error(f"Vulnerability Found (Safety DB): {cve} - {description}")
        except Exception as e:
            self.add_warning(f"Could not check the Safety DB: {e}")

    def _check_snyk(self, pkg_name: str, version: str) -> None:
        """Checks for vulnerabilities using the Snyk API (requires an API key).

        Args:
            pkg_name (str): The name of the package.
            version (str): The version of the package.
        """
        if not self.snyk_api_key:
            self.add_info("Vulnerability Scan (Snyk)", "Skipped: SNYK_API_KEY is not configured.")
            return

        headers = {"Authorization": f"token {self.snyk_api_key}"}
        url = f"{self.SNYK_API_URL}{pkg_name}/{version}"

        try:
            response = requests.get(url, headers=headers, timeout=self.timeout)
            if response.status_code == 404:
                self.add_info("Vulnerability Scan (Snyk)", "No known vulnerabilities found.")
                return
            response.raise_for_status()
            data = response.json()
            for vuln in data.get("vulnerabilities", []):
                self.add_error(f"Vulnerability Found (Snyk): {vuln.get('id', 'N/A')} - {vuln.get('title', 'No title')}")
        except requests.RequestException as e:
            self.add_warning(f"Could not query the Snyk API: {e}")

    def _check_semgrep_rules(self, pkg_name: str, version: str) -> None:
        """Placeholder for checking vulnerabilities using Semgrep rules."""
        self.add_info("Vulnerability Scan (Semgrep)", "This check is not yet implemented.")

    def _get_safety_db(self) -> Dict[str, Any]:
        """Fetches the Safety DB from GitHub, with a local file cache.

        Returns:
            Dict[str, Any]: The contents of the Safety DB.
        """
        cache_path = Path.home() / ".cache" / "pipq" / "safety_db.json"
        if cache_path.exists() and time.time() - cache_path.stat().st_mtime < 3600:
            with open(cache_path, "r", encoding="utf-8") as f:
                return json.load(f)

        url = "https://raw.githubusercontent.com/pyupio/safety-db/master/data/insecure_full.json"
        response = requests.get(url, timeout=self.timeout)
        response.raise_for_status()
        data = response.json()

        cache_path.parent.mkdir(parents=True, exist_ok=True)
        with open(cache_path, "w", encoding="utf-8") as f:
            json.dump(data, f)
        return data

    def _fetch_osv_vulnerabilities(self, package_name: str) -> Dict[str, Any]:
        """Fetches vulnerability data for a package from the OSV API.

        Args:
            package_name (str): The name of the package.

        Returns:
            Dict[str, Any]: The JSON response from the OSV API.
        """
        query = {"package": {"name": package_name, "ecosystem": "PyPI"}}
        response = requests.post(self.OSV_API_URL, json=query, timeout=self.timeout)
        response.raise_for_status()
        return response.json()

    def _is_version_affected(self, package_version_str: str, affected_ranges: List[Dict[str, Any]]) -> bool:
        """Checks if a given package version falls within the affected ranges from OSV.

        Args:
            package_version_str (str): The version of the package to check.
            affected_ranges (List[Dict[str, Any]]): The list of affected ranges from an OSV entry.

        Returns:
            bool: True if the version is affected, False otherwise.
        """
        try:
            package_version = parse_version(package_version_str)
        except Exception:
            return False  # Cannot parse version, assume not affected.

        for affected in affected_ranges:
            for range_info in affected.get("ranges", []):
                if range_info.get("type") == "ECOSYSTEM":
                    events = sorted(range_info.get("events", []), key=lambda e: "fixed" in e)
                    is_affected = False
                    specifiers = []
                    for event in events:
                        if 'introduced' in event:
                            version = event['introduced']
                            if version != "0":
                                specifiers.append(f">={version}")
                            is_affected = True
                        if 'fixed' in event:
                            version = event['fixed']
                            specifiers.append(f"<{version}")
                            is_affected = False
                    if is_affected and not specifiers:
                        return True  # Affected from the start and never fixed.
                    if specifiers and SpecifierSet(",".join(specifiers)).contains(package_version):
                        return True
        return False
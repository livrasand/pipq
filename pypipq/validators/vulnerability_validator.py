
import json
from pathlib import Path
import time
import requests
from packaging.specifiers import SpecifierSet
from packaging.version import parse as parse_version

from ..core.base_validator import BaseValidator
from ..utils.vulnerability_db import VulnerabilityDB
from typing import Dict, Any, List


class VulnerabilityValidator(BaseValidator):
    """
    Validator that checks for known vulnerabilities in packages using the OSV API.
    """
    OSV_API_URL = "https://api.osv.dev/v1/query"

    def __init__(self, pkg_name: str, metadata: Dict[str, Any]):
        super().__init__(pkg_name, metadata)
        self.db = VulnerabilityDB()
        self.timeout = 30

    def _validate(self) -> None:
        """
        Validates the package by checking for vulnerabilities from multiple sources.
        """
        pkg_name = self.get_metadata_field("name")
        version = self.get_metadata_field("version")

        if not pkg_name:
            self.add_warning("Could not determine package name, skipping vulnerability check.")
            return
        if not version or version == 'latest':
            self.add_warning(f"Could not determine version for '{pkg_name}', skipping vulnerability check.")
            return

        self._check_osv(pkg_name, version)
        self._check_safety_db(pkg_name, version)

    def _check_osv(self, pkg_name: str, version: str) -> None:
        """
        Checks for vulnerabilities using the OSV API.
        """
        with self.db:
            vulnerabilities = self.db.get_vulnerability(pkg_name)

            if vulnerabilities is None:
                vulnerabilities = self._fetch_vulnerabilities(pkg_name)
                self.db.update_vulnerability(pkg_name, vulnerabilities)

            if not vulnerabilities or not vulnerabilities.get("vulns"):
                self.add_info("Vulnerability Scan (OSV)", f"No known vulnerabilities found for v{version}.")
                return

            for vuln in vulnerabilities["vulns"]:
                if self._is_version_affected(version, vuln.get("affected", [])):
                    summary = vuln.get('summary', 'No summary available.')
                    osv_id = vuln.get('id', 'N/A')
                    self.add_error(f"Vulnerability Found (OSV): {osv_id} - {summary}")

    def _check_safety_db(self, pkg_name: str, version: str) -> None:
        """
        Checks for vulnerabilities using the Safety DB.
        """
        try:
            safety_db = self._get_safety_db()
            if pkg_name in safety_db:
                for spec, cve, description in safety_db[pkg_name]:
                    spec_set = SpecifierSet(spec)
                    if parse_version(version) in spec_set:
                        self.add_error(f"Vulnerability Found (Safety DB): {cve} - {description}")
        except Exception as e:
            self.add_warning(f"Could not check Safety DB: {e}")

    def _get_safety_db(self) -> Dict[str, Any]:
        """
        Fetches the Safety DB from GitHub, with local caching.
        """
        cache_path = Path.home() / ".cache" / "pipq" / "safety_db.json"
        if cache_path.exists() and time.time() - cache_path.stat().st_mtime < 3600:
            with open(cache_path, "r") as f:
                return json.load(f)

        response = requests.get("https://raw.githubusercontent.com/pyupio/safety-db/refs/heads/master/data/insecure_full.json")
        response.raise_for_status()
        data = response.json()

        cache_path.parent.mkdir(parents=True, exist_ok=True)
        with open(cache_path, "w") as f:
            json.dump(data, f)

        return data

    def _fetch_vulnerabilities(self, package_name: str) -> Dict[str, Any]:
        """
        Fetches vulnerabilities from the OSV API.
        """
        query = {
            "package": {
                "name": package_name,
                "ecosystem": "PyPI"
            }
        }
        try:
            response = requests.post(self.OSV_API_URL, json=query, timeout=self.timeout)
            response.raise_for_status()
            return response.json()
        except requests.exceptions.RequestException as e:
            print(f"Warning: Could not fetch vulnerability data for {package_name}: {e}")
            return {}

    def _is_version_affected(self, package_version_str: str, affected_ranges: List[Dict[str, Any]]) -> bool:
        """
        Checks if a package version is within the affected ranges from OSV.
        """
        try:
            package_version = parse_version(package_version_str)
        except Exception:
            return False # Cannot parse version, assume not affected

        for affected in affected_ranges:
            for range_info in affected.get("ranges", []):
                if range_info["type"] == "ECOSYSTEM":
                    events = range_info.get("events", [])
                    # Sort events: introduced versions first, then fixed versions
                    events.sort(key=lambda e: list(e.keys())[0] != 'introduced')
                    
                    affected_specifiers = []
                    is_affected = False

                    for event in events:
                        if 'introduced' in event:
                            version = event['introduced']
                            if version != "0": # "0" means all prior versions are affected
                                affected_specifiers.append(f">={version}")
                            is_affected = True

                        if 'fixed' in event:
                            version = event['fixed']
                            affected_specifiers.append(f"<{version}")
                            is_affected = False # No longer affected after this version
                    
                    if is_affected and not affected_specifiers:
                         # Affected from the start and never fixed
                         return True

                    if affected_specifiers:
                        spec_str = ",".join(affected_specifiers)
                        spec = SpecifierSet(spec_str)
                        if package_version in spec:
                            return True
        return False


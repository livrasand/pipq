import dbm
import json
import time
import portalocker
import errno
import logging
from pathlib import Path
from typing import Optional, Dict, Any

# Default cache directory
DEFAULT_CACHE_DIR = Path.home() / ".cache" / "pipq"
DEFAULT_DB_PATH = DEFAULT_CACHE_DIR / "vuln.db"

# 1 week in seconds
DEFAULT_CACHE_EXPIRATION = 7 * 24 * 60 * 60

class VulnerabilityDB:
    """
    Manages the local vulnerability database (using Python's dbm).
    Improved with proper lock handling and cross-platform support using portalocker.
    """
    def __init__(self, db_path: Path = DEFAULT_DB_PATH, timeout: float = 5.0):
        self.db_path = db_path
        self.db_path.parent.mkdir(parents=True, exist_ok=True)
        self.db: Optional[Any] = None
        self._db_file: Optional[Any] = None
        self.timeout = timeout
        self._lock_acquired = False

    def __enter__(self):
        logger = logging.getLogger(__name__)
        logger.debug("Entering VulnerabilityDB context.")
        try:
            self.db = self._open_with_timeout()
            return self
        except Exception as e:
            print(f"Warning: Could not open vulnerability cache: {e}")
            return self

    def __exit__(self, exc_type, exc_val, exc_tb):
        if self.db:
            try:
                self.db.close()
            except Exception as e:
                print(f"Warning: Error closing vulnerability DB: {e}")
            finally:
                self.db = None

        if self._lock_acquired and self._db_file:
            try:
                portalocker.unlock(self._db_file)
                self._db_file.close()
            except Exception as e:
                print(f"Warning: Error unlocking/closing DB file: {e}")
            finally:
                self._db_file = None
                self._lock_acquired = False

    def _open_with_timeout(self):
        start_time = time.time()
        last_exception = None

        while time.time() - start_time < self.timeout:
            try:
                db_file_path = str(self.db_path)
                # Abrir DBM
                db = dbm.open(db_file_path, 'c')
                # Abrir archivo fÃ­sico para locking
                self._db_file = open(db_file_path, 'r+b')
                portalocker.lock(self._db_file, portalocker.LOCK_EX | portalocker.LOCK_NB)
                self._lock_acquired = True
                return db
            except (*dbm.error, OSError) as e:
                last_exception = e
                if isinstance(e, OSError) and e.errno in (errno.EAGAIN, errno.EACCES):
                    time.sleep(0.1)
                    continue
                else:
                    raise e

        raise TimeoutError(f"Could not open vulnerability database within {self.timeout}s. Last error: {last_exception}")

    def get_vulnerability(self, package_name: str) -> Optional[Dict[str, Any]]:
        logger = logging.getLogger(__name__)
        if not self.db:
            logger.warning("Vulnerability DB not open, cannot get vulnerability.")
            return None

        key = f"vuln:{package_name}"
        try:
            if key.encode('utf-8') not in self.db:
                logger.debug(f"Cache miss for vulnerability: {package_name}")
                return None

            cached_data = self.db[key.encode('utf-8')]
            data = json.loads(cached_data.decode('utf-8'))
            if time.time() - data.get("timestamp", 0) > DEFAULT_CACHE_EXPIRATION:
                logger.info(f"Cache expired for vulnerability: {package_name}")
                return None
            logger.debug(f"Cache hit for vulnerability: {package_name}")
            return data.get("vulnerabilities")
        except (json.JSONDecodeError, KeyError, TypeError, dbm.error) as e:
            print(f"Warning: Error reading vulnerability cache for {package_name}: {e}")
            return None

    def update_vulnerability(self, package_name: str, vulnerabilities: Dict[str, Any]):
        logger = logging.getLogger(__name__)
        if not self.db:
            logger.warning("Vulnerability DB not open, cannot update vulnerability.")
            return

        key = f"vuln:{package_name}"
        logger.debug(f"Updating vulnerability cache for {package_name}")
        data = {
            "timestamp": time.time(),
            "vulnerabilities": vulnerabilities,
        }

        try:
            self.db[key.encode('utf-8')] = json.dumps(data).encode('utf-8')
        except (dbm.error, OSError) as e:
            print(f"Warning: Could not update vulnerability cache for {package_name}: {e}")

    def close(self):
        """Manually close the database and release lock."""
        if self.db:
            try:
                self.db.close()
            except Exception as e:
                print(f"Warning: Error closing vulnerability database: {e}")
            finally:
                self.db = None

        if self._lock_acquired and self._db_file:
            try:
                portalocker.unlock(self._db_file)
                self._db_file.close()
            except Exception as e:
                print(f"Warning: Error unlocking/closing DB file: {e}")
            finally:
                self._db_file = None
                self._lock_acquired = False

class FileBasedVulnerabilityCache:
    """
    Fallback vulnerability cache using individual JSON files instead of DBM.
    Used when DBM is not available or has locking issues.
    """
    def __init__(self, cache_dir: Path = DEFAULT_CACHE_DIR):
        self.cache_dir = cache_dir / "vuln_cache"
        self.cache_dir.mkdir(parents=True, exist_ok=True)

    def get_vulnerability(self, package_name: str) -> Optional[Dict[str, Any]]:
        logger = logging.getLogger(__name__)
        """Get vulnerability data from individual JSON file."""
        cache_file = self.cache_dir / f"{package_name}.json"
        
        if not cache_file.exists():
            logger.debug(f"File cache miss for vulnerability: {package_name}")
            return None
            
        try:
            with open(cache_file, 'r') as f:
                data = json.load(f)
                
            if time.time() - data.get("timestamp", 0) > DEFAULT_CACHE_EXPIRATION:
                # Cache expired, remove file
                logger.info(f"File cache expired for vulnerability: {package_name}")
                cache_file.unlink(missing_ok=True)
                return None
            
            logger.debug(f"File cache hit for vulnerability: {package_name}")
            return data.get("vulnerabilities")
        except (json.JSONDecodeError, IOError) as e:
            print(f"Warning: Error reading vulnerability cache file for {package_name}: {e}")
            return None

    def update_vulnerability(self, package_name: str, vulnerabilities: Dict[str, Any]):
        logger = logging.getLogger(__name__)
        """Update vulnerability data in individual JSON file."""
        logger.debug(f"Updating file cache for {package_name}")
        cache_file = self.cache_dir / f"{package_name}.json"
        data = {
            "timestamp": time.time(),
            "vulnerabilities": vulnerabilities,
        }
        
        try:
            with open(cache_file, 'w') as f:
                json.dump(data, f)
        except IOError as e:
            print(f"Warning: Could not update vulnerability cache file for {package_name}: {e}")
"""Manages a local cache for package vulnerability data.

This module provides classes for creating and interacting with a local
vulnerability database. It features a primary DBM-based implementation with
file locking for safe concurrent access, and a simpler file-based fallback.
"""
import dbm
import json
import time
import portalocker
import errno
import logging
import sys
from pathlib import Path
from typing import Optional, Dict, Any
from bloom_filter import BloomFilter

# Initialize a logger for this module.
logger = logging.getLogger(__name__)

# Default location for the cache directory and database file.
DEFAULT_CACHE_DIR = Path.home() / ".cache" / "pipq"
DEFAULT_DB_PATH = DEFAULT_CACHE_DIR / "vuln.db"

# Default cache entry expiration time: 1 week in seconds.
DEFAULT_CACHE_EXPIRATION = 7 * 24 * 60 * 60


class VulnerabilityDB:
    """Manages a DBM-based local vulnerability database with file locking.

    This class provides a context manager interface for safe, concurrent access
    to a shared DBM file. It uses `portalocker` to acquire an exclusive lock,
    preventing race conditions when multiple processes might access the cache.

    Attributes:
        db_path (Path): The path to the DBM database file.
        timeout (float): The maximum time in seconds to wait for the lock.
    """
    def __init__(self, db_path: Path = DEFAULT_DB_PATH, timeout: float = 5.0):
        """Initializes the VulnerabilityDB manager.

        Args:
            db_path (Path): The path to the database file.
            timeout (float): The time in seconds to wait for the file lock.
        """
        self.db_path = db_path
        self.db_path.parent.mkdir(parents=True, exist_ok=True)
        self.lock_file = self.db_path.with_suffix('.lock')
        self.timeout = timeout
        self.db: Optional[Any] = None
        self._lock_fd: Optional[Any] = None
        self._lock_acquired = False

    def __enter__(self):
        """Enters the context, acquiring a lock and opening the database."""
        logger.debug("Entering VulnerabilityDB context and acquiring lock.")
        try:
            self.db = self._open_with_timeout()
        except (TimeoutError, OSError, dbm.error) as e:
            print(f"Warning: Could not open vulnerability cache: {e}", file=sys.stderr)
            self.db = None
        return self

    def __exit__(self, exc_type, exc_val, exc_tb):
        """Exits the context, closing the database and releasing the lock."""
        logger.debug("Exiting VulnerabilityDB context and releasing lock.")
        self.close()

    def _open_with_timeout(self) -> Any:
        """Tries to acquire a lock and open the DBM file within a timeout."""
        start_time = time.time()
        while time.time() - start_time < self.timeout:
            try:
                self._lock_fd = open(self.lock_file, 'w')
                portalocker.lock(self._lock_fd, portalocker.LOCK_EX | portalocker.LOCK_NB)
                self._lock_acquired = True
                return dbm.open(str(self.db_path), 'c')
            except (portalocker.LockException, OSError) as e:
                if isinstance(e, OSError) and e.errno in (errno.EAGAIN, errno.EACCES):
                    time.sleep(0.1)  # Wait and retry on specific lock-related OS errors
                elif isinstance(e, portalocker.LockException):
                    time.sleep(0.1)  # Wait and retry if portalocker signals a lock
                else:
                    self.close()  # Release resources on unexpected error
                    raise
        raise TimeoutError(f"Could not acquire lock on {self.lock_file} within {self.timeout}s.")

    def get_vulnerability(self, package_name: str) -> Optional[Dict[str, Any]]:
        """Retrieves vulnerability data for a package from the cache.

        Args:
            package_name (str): The name of the package.

        Returns:
            Optional[Dict[str, Any]]: The vulnerability data if found and not
            expired, otherwise None.
        """
        if not self.db:
            logger.warning("DB not open, cannot get vulnerability for %s.", package_name)
            return None

        key = f"vuln:{package_name}".encode('utf-8')
        try:
            if key not in self.db:
                logger.debug("Cache miss for vulnerability: %s", package_name)
                return None

            cached_data = self.db[key]
            data = json.loads(cached_data.decode('utf-8'))
            if time.time() - data.get("timestamp", 0) > DEFAULT_CACHE_EXPIRATION:
                logger.info("Cache expired for vulnerability: %s", package_name)
                del self.db[key]  # Remove expired entry
                return None

            logger.debug("Cache hit for vulnerability: %s", package_name)
            return data.get("vulnerabilities")
        except (json.JSONDecodeError, KeyError, TypeError, dbm.error) as e:
            print(f"Warning: Error reading cache for {package_name}: {e}", file=sys.stderr)
            return None

    def update_vulnerability(self, package_name: str, vulnerabilities: Dict[str, Any]):
        """Updates or adds vulnerability data for a package in the cache.

        Args:
            package_name (str): The name of the package.
            vulnerabilities (Dict[str, Any]): The vulnerability data to store.
        """
        if not self.db:
            logger.warning("DB not open, cannot update vulnerability for %s.", package_name)
            return

        key = f"vuln:{package_name}".encode('utf-8')
        data = {"timestamp": time.time(), "vulnerabilities": vulnerabilities}
        try:
            self.db[key] = json.dumps(data).encode('utf-8')
            logger.debug("Updated vulnerability cache for %s", package_name)
        except (dbm.error, OSError) as e:
            print(f"Warning: Could not update cache for {package_name}: {e}", file=sys.stderr)

    def close(self):
        """Closes the database and releases the file lock."""
        if self.db:
            try:
                self.db.close()
            except dbm.error as e:
                print(f"Warning: Error closing vulnerability DB: {e}", file=sys.stderr)
            finally:
                self.db = None

        if self._lock_acquired and self._lock_fd:
            try:
                portalocker.unlock(self._lock_fd)
                self._lock_fd.close()
            except (OSError, portalocker.LockException) as e:
                print(f"Warning: Error closing lock file: {e}", file=sys.stderr)
            finally:
                self._lock_fd = None
                self._lock_acquired = False


class FileBasedVulnerabilityCache:
    """A fallback vulnerability cache using individual JSON files.

    This implementation is simpler than `VulnerabilityDB` and is used as a
    fallback. It does not provide locking, making it less safe for highly

    concurrent environments.

    Attributes:
        cache_dir (Path): The directory for storing vulnerability JSON files.
    """
    def __init__(self, cache_dir: Path = DEFAULT_CACHE_DIR):
        """Initializes the file-based cache."""
        self.cache_dir = cache_dir / "vuln_cache"
        self.cache_dir.mkdir(parents=True, exist_ok=True)

    def get_vulnerability(self, package_name: str) -> Optional[Dict[str, Any]]:
        """Retrieves vulnerability data from a dedicated JSON file.

        Args:
            package_name (str): The name of the package.

        Returns:
            Optional[Dict[str, Any]]: The vulnerability data if found and not
            expired, otherwise None.
        """
        cache_file = self.cache_dir / f"{package_name}.json"
        if not cache_file.exists():
            logger.debug("File cache miss for vulnerability: %s", package_name)
            return None

        try:
            with open(cache_file, 'r', encoding='utf-8') as f:
                data = json.load(f)
            if time.time() - data.get("timestamp", 0) > DEFAULT_CACHE_EXPIRATION:
                logger.info("File cache expired for vulnerability: %s", package_name)
                cache_file.unlink(missing_ok=True)
                return None
            logger.debug("File cache hit for vulnerability: %s", package_name)
            return data.get("vulnerabilities")
        except (json.JSONDecodeError, IOError, KeyError) as e:
            print(f"Warning: Error reading cache file for {package_name}: {e}", file=sys.stderr)
            return None

    def update_vulnerability(self, package_name: str, vulnerabilities: Dict[str, Any]):
        """Updates vulnerability data in a dedicated JSON file.

        Args:
            package_name (str): The name of the package.
            vulnerabilities (Dict[str, Any]): The vulnerability data to store.
        """
        logger.debug("Updating file cache for %s", package_name)
        cache_file = self.cache_dir / f"{package_name}.json"
        data = {"timestamp": time.time(), "vulnerabilities": vulnerabilities}
        try:
            with open(cache_file, 'w', encoding='utf-8') as f:
                json.dump(data, f)
        except (IOError, TypeError) as e:
            print(f"Warning: Could not update cache file for {package_name}: {e}", file=sys.stderr)


class VulnerabilityCache:
    """A probabilistic cache for vulnerability checks using a Bloom filter.

    This class is intended to provide a fast, memory-efficient way to check if
    a package version is likely to be in the main vulnerability database.

    Note: This class appears to be incomplete.
    """
    def __init__(self, capacity: int = 100000, error_rate: float = 0.001):
        """Initializes the Bloom filter.

        Args:
            capacity (int): The expected number of items to be stored.
            error_rate (float): The desired false positive probability.
        """
        self.bloom_filter = BloomFilter(capacity=capacity, error_rate=error_rate)

    def check_vulnerability(self, package: str, version: str) -> Optional[bool]:
        """Checks if a package version might be vulnerable.

        Args:
            package (str): The name of the package.
            version (str): The version of the package.

        Returns:
            Optional[bool]: None if the item is definitely not in the filter
            (not vulnerable according to the cache). True if the item might be
            present, indicating a full DB check is needed.
        """
        key = f"{package}:{version}"
        if key not in self.bloom_filter:
            return None  # Definitely not present.
        return True  # Possibly present, requires a full check.